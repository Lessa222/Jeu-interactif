<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Jeu</title>
    <style>body{margin:0}</style>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
<script>
const config = {
    type: Phaser.AUTO,
    width: 900,
    height: 500,
    backgroundColor: '#87CEEB',
    physics: {
        default: 'arcade',
        arcade: { gravity: { y: 0 }, debug: false }
    },
    scene: { preload, create, update }
};

const game = new Phaser.Game(config);

let player, cursors, enemies;
let gameOver = false;
let score = 0;
let scoreText;
let spawnDelay = 1200;    // délai initial en ms
let enemySpeed = 60;      // vitesse initiale des ennemis (px/s)
const MIN_SPAWN = 300;
const SPEED_INC = 6;      // augmentation de vitesse par spawn
const DELAY_DEC = 20;     // réduction du délai par spawn (ms)
let highscore = 0;
let highscoreText;
let bullets;
let shootKey;
let lastShot = 0;
let particles;
const SHOT_COOLDOWN = 20; // temps entre les tirs en ms
let lives = 3;
let livesText;
let lifePickups;
let powerups;
let invincible = false;
let rapidFire = false;
let asteroids;

function preload() {
    this.load.image('bg', 'background.jpg');
    // vérifie que '1.png' existe dans public ou adapte le chemin
    this.load.image('mario', '1.png');
    this.load.image('enemyTex', '2.png');
    this.load.image('life', '4.png');
    this.load.image('bulletTex', 'rocket.png');
    this.load.audio('shootSound', 'tir.mp3');
    this.load.image('asteroidTex', 'vato.png');
    this.load.image('powerupTex', 'diamond.png');
}

function create() {
      const bg = this.add.image(0, 0, 'bg').setOrigin(0, 0);
      bg.setDisplaySize(config.width, config.height);
    // instructions + sco
    gameOver = false;
    score = 0;
    lives = 3;
    spawnDelay = 1200;
    enemySpeed = 60;
    this.add.text(8, 8, 'Évite les ennemis — flèches pour bouger', { fontSize: '18px', fill: '#000' });
    scoreText = this.add.text(8, 36, 'Score: 0', { fontSize: '18px', fill: '#000' });

    // joueur
    player = this.physics.add.sprite(config.width/4, config.height - 80, 'mario');
    player.setScale(0.15);
    player.setCollideWorldBounds(true);

    cursors = this.input.keyboard.createCursorKeys();
    soundShoot = this.sound.add('shootSound');

    // texture runtime pour ennemis
    const g = this.add.graphics();
    g.fillStyle(0xff0000, 1);
    g.fillRect(0, 0, 20, 20);
    g.generateTexture('enemyTex', 20, 20);
    g.destroy();

    enemies = this.physics.add.group();
    // texture runtime pour balles
    const gb = this.add.graphics();
    gb.fillStyle(0x000000, 1);
    gb.fillRect(0, 0, 4, 12);
    gb.generateTexture('bulletTex', 4, 12);
    gb.destroy();
   
    // bullets group
    bullets = this.physics.add.group({
        defaultKey: 'bulletTex',
        maxSize: 20
    });

    // overlap bullets -> enemies
    this.physics.add.overlap(bullets, enemies, (b, e) => {
        if (b && b.active) b.destroy();
        if (e && e.active) e.destroy();
    }, null, this);

    shootKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    const gl = this.add.graphics();
    gl.fillStyle(0x00ff00, 1); // vert
    gl.fillRect(0, 0, 15, 15);
    gl.generateTexture('life', 15, 15);
    gl.destroy();

    lifePickups = this.physics.add.group();

    // overlap joueur -> life pickup
    this.physics.add.overlap(player, lifePickups, (p, life) => {
        lives++;
        livesText.setText('Lives: ' + lives);
        life.destroy();
    }, null, this);

    // collision -> game over
    this.physics.add.overlap(player, enemies, onHit, null, this);

    // lance la première spawn après spawnDelay
    this.time.delayedCall(spawnDelay, spawnEnemy, [], this);
      // load highscore from localStorage
    highscore = parseInt(localStorage.getItem('highscore') || '0', 10) || 0;
    highscoreText = this.add.text(8, 64, 'Highscore: ' + highscore, { fontSize: '18px', fill: '#000' });
    livesText = this.add.text(8, 92, 'Lives: ' + lives, { fontSize: '18px', fill: '#000' });
     const gPowerup = this.add.graphics();
    gPowerup.fillStyle(0xffff00, 1);
    gPowerup.fillRect(0, 0, 20, 20);
    gPowerup.generateTexture('powerupTex', 20, 20);
    gPowerup.destroy();

    powerups = this.physics.add.group();

    // overlap joueur -> powerup
        this.physics.add.overlap(player, powerups, (p, pu) => {
        activatePowerup(pu.type, this);
        pu.destroy();
    }, null, this);
        const ga = this.add.graphics();
    ga.fillStyle(0x808080, 1); // gris
    ga.fillCircle(12, 12, 12);
    ga.generateTexture('asteroidTex', 24, 24);
    ga.destroy();

    asteroids = this.physics.add.group();
        this.physics.add.overlap(player, asteroids, (p, a) => {
        // réutilise la logique de collision (perte de vie, game over)
        onHit(p, a);
    }, null, this);
        this.time.addEvent({
        delay: 10000, // toutes les 10s (ajuste si besoin)
        callback: spawnAsteroid,
        callbackScope: this,
        loop: true
    });
}

function spawnEnemy() {if (gameOver) return;

    // augmenter la vitesse avant de spawn pour qu'elle affecte l'ennemi créé
    enemySpeed += SPEED_INC;
    // optionnel : limiter la vitesse max
    const MAX_ENEMY_SPEED = 800;
    enemySpeed = Math.min(enemySpeed, MAX_ENEMY_SPEED);

    const x = Phaser.Math.Between(20, config.width - 20);
    const enemy = enemies.create(x, -30, 'enemyTex');

    // appliquer la vitesse calculée
    enemy.setVelocityY(enemySpeed);
    enemy.body.setAllowGravity(false);
    enemy.setScale(0.2);

    // score = nombre d'ennemis spawnés
    score++;
    scoreText.setText('Score: ' + score);

    // réduire le délai de spawn progressivement
    spawnDelay = Math.max(MIN_SPAWN, spawnDelay - DELAY_DEC);

    // re-planifier le spawn suivant
    this.time.delayedCall(spawnDelay, spawnEnemy, [], this);
        if (Phaser.Math.Between(1, 100) <= 20) {
        const lx = Phaser.Math.Between(20, config.width - 20);
        const life = lifePickups.create(lx, -30, 'life'); // <-- utilise 'life' et non 'lifeTex'
        life.setVelocityY(80);
        life.body.setAllowGravity(false);
        // life.setScale(0.5); // optionnel : ajuste la taille si nécessaire
    }
        if (Phaser.Math.Between(1, 100) <= 10) {
        const lpx = Phaser.Math.Between(20, config.width - 20);
        const powerup = powerups.create(lpx, -30, 'powerupTex');
        powerup.setVelocityY(80);
        powerup.body.setAllowGravity(false);
        powerup.type = Phaser.Math.Between(0, 1); // 0 = invincibilité, 1 = tir rapide
    }
 // ..
}
function shoot(scene) {
    if (gameOver) return;
    const now = scene.time.now;
    const cooldown = rapidFire ? 5 : SHOT_COOLDOWN; // 5ms si rapidFire, sinon 20ms
    if (now - lastShot < cooldown) return;
    lastShot = now;

    const bx = player.x;
    const by = player.y - 20;
    const bullet = bullets.get(bx, by, 'bulletTex');
    if (!bullet) return;

    bullet.setActive(true);
    bullet.setVisible(true);
    bullet.body.enable = true;
    bullet.setVelocityY(-450);
    soundShoot.play();
}

function onHit(playerObj, enemy) {
    if (gameOver) return;

    // si invincible, ne rien faire
    if (invincible) {
        enemy.destroy();
        return;
    }
    
    lives--;
    livesText.setText('Lives: ' + lives);
    
    player.x = config.width / 2;
    player.y = config.height - 80;
    player.body.setVelocity(0);
    
    enemy.destroy();
    
    if (lives <= 0) {
        gameOver = true;
        
        if (score > highscore) {
            highscore = score;
            localStorage.setItem('highscore', String(highscore));
            highscoreText.setText('Highscore: ' + highscore);
        }

        this.add.text(config.width/2, config.height/2 - 30, 'GAME OVER', { fontSize: '48px', fill: '#ff0000' }).setOrigin(0.5);
        this.add.text(config.width/2, config.height/2 + 10, 'Score: ' + score, { fontSize: '24px', fill: '#000' }).setOrigin(0.5);
        this.add.text(config.width/2, config.height/2 + 50, 'Appuie sur R pour recommencer', { fontSize: '16px', fill: '#000' }).setOrigin(0.5);

        this.input.keyboard.once('keydown-R', () => {
            this.scene.restart();
        });
    }
}
function activatePowerup(type, scene) {
    if (type === 0) {
        // invincibilité 4 secondes
        invincible = true;
        player.setTint(0x00ff00); // teinte verte
        scene.time.delayedCall(4000, () => {
            invincible = false;
            player.clearTint();
        });
    } else if (type === 1) {
        // tir rapide 3 secondes
        rapidFire = true;
        player.setTint(0xff00ff); // teinte magenta
        scene.time.delayedCall(3000, () => {
            rapidFire = false;
            player.clearTint();
        });
    }
}
function spawnAsteroid() {
    if (gameOver) return;

    const x = Phaser.Math.Between(20, config.width - 20);
    const asteroid = asteroids.create(x, -40, 'asteroidTex');
    asteroid.setVelocityY(Phaser.Math.Between(70, 140));
    asteroid.body.setAllowGravity(false);
    asteroid.setScale(Phaser.Math.FloatBetween(0.6, 1.4));
    asteroid.setImmovable(true);
    // marque éventuellement pour debug
    asteroid.isAsteroid = true;
}
function update() {
    if (gameOver) return;

    const speed = 300;
    player.body.setVelocity(0);
    if (cursors.left.isDown) player.body.setVelocityX(-speed);
    else if (cursors.right.isDown) player.body.setVelocityX(speed);
    if (cursors.up.isDown) player.body.setVelocityY(-speed);
    else if (cursors.down.isDown) player.body.setVelocityY(speed);

    // supprimer ennemis hors écran
    enemies.children.each((e) => {
        if (e.y > config.height + 50) e.destroy();
    });
     if (Phaser.Input.Keyboard.JustDown(shootKey)) {
        shoot(this);
    }
        lifePickups.children.each((l) => {
        if (l.y > config.height + 50) l.destroy();
    });
    // clean bullets off-screen
    bullets.children.each((b) => {
        if (b.y < -20) b.destroy();
    });
      if (asteroids) {
        asteroids.children.each((a) => {
            if (a && a.y > config.height + 50) a.destroy();
        });
    }
     bullets.children.each((b) => {
        if (b.y < -20) b.destroy();
    });
    
}
</script>
</body>
</html>